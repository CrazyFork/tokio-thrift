
pub trait {{service.ident}}Service: Send {{#if service.extends ~}}+ {{service.extends}} {{/if}}{
    {{~#each service.methods as |method|}}
    {{> method method = method}};
    {{~/each}}
}


#[derive(Debug, Clone)]
pub enum {{service.ident}}ServiceMethodArgs {
    {{~#each service.methods as |method|}}
    A{{method.ident}}({{../service.ident}}{{method.ident}}Args),
    {{~/each}}
}


impl Serialize for {{service.ident}}ServiceMethodArgs {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        use self::{{service.ident}}ServiceMethodArgs::*;
        match self {
            {{~#each service.methods as |method|}}
            &A{{method.ident}}(ref b) => {
                try!(s.write_message_begin("{{method.ident}}", ThriftMessageType::Call));
                try!(b.serialize(s));
                try!(s.write_message_end());
            },
            {{~/each}}
        };
        Ok(())
    }
}

impl Deserialize for {{service.ident}}ServiceMethodArgs {
    fn deserialize<D>(de: &mut D) -> Result<Self, Error>
        where D: Deserializer + ThriftDeserializer,
    {
        let msg = try!(de.read_message_begin());
        //assert!(msg.type) == $msg_type
        let ret = match msg.name.as_ref() {
            {{~#each service.methods as |method|}}
            "{{method.ident}}" => {{../service.ident}}ServiceMethodArgs::A{{method.ident}}({{../service.ident}}{{method.ident}}Args::deserialize(de)?),
            {{~/each}}
            _ => return Err(Error::from(io::Error::new(io::ErrorKind::InvalidData, "failed to parse thrift data"))),
        };
        let _ = try!(de.read_message_end());
        Ok(ret)
    }
}


#[derive(Debug, Clone)]
pub enum {{service.ident}}ServiceMethodReturn {
    {{~#each service.methods as |method|}}
    // FIXME: generate exception too
    R{{method.ident}}(Result<{{to_rust method.ty}}, ()>),
    {{~/each}}

}


impl Serialize for {{service.ident}}ServiceMethodReturn {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        use self::{{service.ident}}ServiceMethodReturn::*;
        match self {
            {{~#each service.methods as |method|}}
            &R{{method.ident}}(ref b) => {
                match b {
                    &Ok(ref b) => {
                        try!(s.write_message_begin("{{method.ident}}", ThriftMessageType::Reply));
                        try!(b.serialize(s));
                        try!(s.write_message_end());
                    },
                    &Err(_) => panic!("exception is not supported yet"),
                }
            },
            {{~/each}}
        };
        Ok(())
    }
}

impl Deserialize for {{service.ident}}ServiceMethodReturn {
    fn deserialize<D>(de: &mut D) -> Result<Self, Error>
        where D: Deserializer + ThriftDeserializer,
    {
        let msg = try!(de.read_message_begin());
        // if msg.type == return
        let ret = match msg.name.as_ref() {
            {{~#each service.methods as |method|}}
            "{{method.ident}}" => {{../service.ident}}ServiceMethodReturn::R{{method.ident}}(Ok({{to_rust method.ty}}::deserialize(de)?)),
            {{~/each}}
            _ => return Err(Error::from(io::Error::new(io::ErrorKind::InvalidData, "failed to parse thrift data"))),
        };
        // else msg.type == exception
        // FIXME:

        let _ = try!(de.read_message_end());
        Ok(ret)
    }
}


{{#each service.methods as |method| ~}}
#[derive(Debug, Clone)]
pub struct {{../service.ident}}{{method.ident}}Args {
    {{~#each method.args as |arg|}}
    {{#if field.optional ~}}
    pub {{arg.ident}}: Option<{{to_rust arg.ty}}>,
    {{~^~}}
    pub {{arg.ident}}: {{to_rust arg.ty}},
    {{~/if~}}
    {{~/each}}
}
{{/each ~}}

{{#each service.methods as |method| ~}}
impl Serialize for {{../service.ident}}{{method.ident}}Args {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        try!(s.write_struct_begin("{{../service.ident}}_{{method.ident}}_Args"));
        {{#each method.args as |arg|~}}
        {{#if field.optional~}}
        if self.{{arg.ident}}.is_some() {
            try!(s.write_field_begin("{{arg.ident}}", {{to_protocol arg.ty}}, {{arg.seq}}));
            try!(self.{{arg.ident}}.serialize(s));
            try!(s.write_field_end());
        }
        {{~^~}}
        try!(s.write_field_begin("{{arg.ident}}", {{to_protocol arg.ty}}, {{arg.seq}}));
        try!(self.{{arg.ident}}.serialize(s));
        try!(s.write_field_end());
        {{/if}}
        {{~/each~}}
        try!(s.write_field_stop());
        try!(s.write_struct_end());
        Ok(())
    }
}
{{/each}}

{{#each service.methods as |method|}}
impl Deserialize for {{../service.ident}}{{method.ident}}Args {
    fn deserialize<D>(de: &mut D) -> Result<Self, Error>
        where D: Deserializer + ThriftDeserializer,
    {
        try!(de.read_struct_begin());
        {{#each args as |arg|~}}
        let mut {{arg.ident}} = None;
        {{~/each}}
        loop {
            let scheme_field = try!(de.read_field_begin());
            if scheme_field.ty == ThriftType::Stop {
                break;
            };
            match scheme_field.seq {
                {{#each args as |arg|~}}
                {{arg.seq}} => {
                    if scheme_field.ty == {{to_protocol arg.ty}} {
                        {{arg.ident}} = Some(try!({{expr arg.ty}}));
                    } else {
                        // skip
                    }
                },
                {{~/each}}
                _ => (),// skip
            }
            try!(de.read_field_end());
        };
        try!(de.read_struct_end());
        let args = {{../service.ident}}{{method.ident}}Args {
            {{#each args as |arg|~}}
            {{#if field.optional ~}}
            {{arg.ident}}: {{arg.ident}},
            {{~^~}}
            {{arg.ident}}: {{arg.ident}}.unwrap(),
            {{/if}}
            {{~/each}}
        };
        Ok(args)
    }
}
{{/each}}

