
pub trait {{service.ident}}Service: Send {
    {{~#each service.methods as |method|}}
    {{> method method = method}};
    {{~/each}}
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum {{service.ident}}ServiceMethods {
    {{~#each service.methods as |method|}}
    M{{method.ident}},
    {{~/each}}
}

impl FromStr for {{service.ident}}ServiceMethods {
    type Err = io::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        use self::{{service.ident}}ServiceMethods::*;
        match s {
            {{~#each service.methods as |method|}}
            "{{method.ident}}" => Ok(M{{method.ident}}),
            {{~/each}}
            _ => Err(io::Error::new(io::ErrorKind::InvalidData, "failed to parse thrift method data"))
        }
    }
}


impl ParseThrift for {{service.ident}}ServiceMethods {
    type Args = {{service.ident}}ServiceMethodArgs;
    type Ret = {{service.ident}}ServiceMethodReturn;
    fn parse_args<D: Deserializer + ThriftDeserializer>(&self, proto: &mut D) -> Result<Self::Args, Error> {
        use self::{{service.ident}}ServiceMethodArgs::*;
        use self::{{service.ident}}ServiceMethods::*;
        match self {
            {{~#each service.methods as |method|}}
            &M{{method.ident}} => {{../service.ident}}{{method.ident}}Args::deserialize(proto).map(A{{method.ident}}),
            {{~/each}}
        }
    }

    fn parse_ret<D: Deserializer + ThriftDeserializer>(&self, proto: &mut D) -> Result<Self::Ret, Error> {
        use self::{{service.ident}}ServiceMethodReturn::*;
        use self::{{service.ident}}ServiceMethods::*;
        match self {
            {{~#each service.methods as |method|}}
            &M{{method.ident}} => {{to_rust method.ty}}::deserialize(proto).map(R{{method.ident}}),
            {{~/each}}
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum {{service.ident}}ServiceMethodArgs {
    {{~#each service.methods as |method|}}
    A{{method.ident}}({{../service.ident}}{{method.ident}}Args),
    {{~/each}}
}


impl Serialize for {{service.ident}}ServiceMethodArgs {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        use self::{{service.ident}}ServiceMethodArgs::*;
        match self {
            {{~#each service.methods as |method|}}
            &A{{method.ident}}(ref b) => {
                try!(s.write_message_begin("{{method.ident}}", ThriftMessageType::Call));
                try!(b.serialize(s));
                try!(s.write_message_end());
            },
            {{~/each}}
        };
        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum {{service.ident}}ServiceMethodReturn {
    {{~#each service.methods as |method|}}
    R{{method.ident}}({{to_rust method.ty}}),
    {{~/each}}

}


impl Serialize for {{service.ident}}ServiceMethodReturn {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        use self::{{service.ident}}ServiceMethodReturn::*;
        match self {
            {{~#each service.methods as |method|}}
            &R{{method.ident}}(ref b) => {
                try!(s.write_message_begin("{{method.ident}}", ThriftMessageType::Reply));
                try!(b.serialize(s));
                try!(s.write_message_end());
            },
            {{~/each}}
        };
        Ok(())
    }
}



{{#each service.methods as |method| ~}}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct {{../service.ident}}{{method.ident}}Args {
    {{~#each method.args as |arg|}}
    pub {{arg.ident}}: {{to_rust arg.ty}},
    {{~/each}}
}
{{/each ~}}

{{#each service.methods as |method| ~}}
impl Serialize for {{../service.ident}}{{method.ident}}Args {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        try!(s.write_struct_begin("{{../service.ident}}_{{method.ident}}_Args"));
        {{#each method.args as |arg|~}}
        try!(s.write_field_begin("{{arg.ident}}", {{to_protocol arg.ty}}, {{arg.seq}}));
        try!(self.{{arg.ident}}.serialize(s));
        try!(s.write_field_end());
        {{~/each}}
        try!(s.write_field_stop());
        try!(s.write_struct_end());
        Ok(())
    }
}
{{/each}}


{{#each service.methods as |method|}}
impl Deserialize for {{../service.ident}}{{method.ident}}Args {
    fn deserialize<D>(de: &mut D) -> Result<Self, Error>
        where D: Deserializer + ThriftDeserializer,
    {
        try!(de.read_struct_begin());
        {{#each args as |arg|~}}
        let mut {{arg.ident}} = None;
        {{~/each}}
        loop {
            let scheme_field = try!(de.read_field_begin());
            if scheme_field.ty == ThriftType::Stop {
                break;
            };
            match scheme_field.seq {
                {{#each args as |arg|~}}
                {{arg.seq}} => {
                    if scheme_field.ty == {{to_protocol arg.ty}} {
                        {{arg.ident}} = Some(try!({{expr arg.ty}}));
                    } else {
                        // skip
                    }
                },
                {{~/each}}
                _ => (),// skip
            }
            try!(de.read_field_end());
        };
        try!(de.read_struct_end());
        let args = {{../service.ident}}{{method.ident}}Args {
            {{#each args as |arg|~}}
            {{arg.ident}}: {{arg.ident}}.unwrap(),
            {{~/each}}
        };
        Ok(args)
    }
}
{{/each}}

