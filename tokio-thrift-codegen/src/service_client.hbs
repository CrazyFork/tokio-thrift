pub struct {{service.ident}}ClientCodec;

impl Codec for {{service.ident}}ClientCodec {
    type In = {{service.ident}}ServiceMethodReturn;
    type Out = {{service.ident}}ServiceMethodArgs;

    fn decode(&mut self, buf: &mut EasyBuf) -> Result<Option<Self::In>, io::Error> {
        let cur = io::Cursor::new(buf);
        let mut protocol = BinaryProtocol::from(cur);
        let ret = match Self::In::deserialize(&mut protocol) {
            Ok(ret) => ret,
            Err(Error::EOF) => return Ok(None),
            Err(e) => return Err(io::Error::from(e)),
        };
        let cur = protocol.into_inner();
        let size = cur.position();
        let buf = cur.into_inner();
        buf.drain_to(size as usize);
        Ok(Some(ret))
    }

    fn encode(&mut self, msg: Self::Out, buf: &mut Vec<u8>) -> io::Result<()> {
        let mut protocol = BinaryProtocol::from(buf);
        msg.serialize(&mut protocol).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))

    }
}


pub struct {{service.ident}}ClientProto;

impl<T: Io + 'static> ClientProto<T> for {{service.ident}}ClientProto {
    type Request = {{service.ident}}ServiceMethodArgs;
    type Response = {{service.ident}}ServiceMethodReturn;
    type Transport = Framed<T, {{service.ident}}ClientCodec>;
    type BindTransport = Result<Self::Transport, io::Error>;

    fn bind_transport(&self, io: T) -> Self::BindTransport {
        Ok(io.framed({{service.ident}}ClientCodec))
    }
}


pub struct {{service.ident}}Client<T: 'static+Io> {
    client: ClientService<T, {{service.ident}}ClientProto>,
}

impl <T: 'static+Io>{{service.ident}}Client<T> {
    pub fn new(client: ClientService<T, {{service.ident}}ClientProto>) -> Self {
        {{service.ident}}Client {
            client: client,
        }
    }
}

impl <T: 'static+Io>{{service.ident}}Service for {{service.ident}}Client<T> {
    {{~#each service.methods as |method|}}
    {{> method method = method}} {
        use {{../namespace}}::{{../service.ident}}ServiceMethodArgs::*;
        use {{../namespace}}::{{../service.ident}}ServiceMethodReturn::*;
        let args = {{../service.ident}}{{method.ident}}Args {
            {{~#each args as |arg| }}
            {{arg.ident}}: {{arg.ident}},
            {{~/each}}
        };
        self.client
            .call(A{{method.ident}}(args))
            .then(|ret| match ret {
                Ok(R{{method.ident}}(Ok(s))) => Ok(s),
                Ok(R{{method.ident}}(Err(_))) |
                Err(_) => panic!("exception is not supported yet"),
                Ok(_) => panic!("tokio-thrift internal error. may be a bug"),
            }).boxed()
    }
{{~/each}}
}

