pub struct {{service.ident}}Client {
    inner: easy::EasyClient<{{service.ident}}ServiceMethodArgs, {{service.ident}}ServiceMethodReturn>,
}

impl {{service.ident}}Client {
    pub fn new(handle: &Handle, stream: TcpStream) -> Self {
        let transport = new_thrift_client_transport::<_, {{service.ident}}ServiceMethods, {{service.ident}}ServiceMethodArgs>(stream);
        let easy_client = easy::pipeline::connect(transport, handle);

        {{service.ident}}Client { inner: easy_client }
    }
}

impl Service for {{service.ident}}Client {
    type Request = {{service.ident}}ServiceMethodArgs;
    type Response = {{service.ident}}ServiceMethodReturn;
    type Error = io::Error;
    type Future = Box<Future<Item = Self::Response, Error = Self::Error>>;

    fn call(&self, arg: Self::Request) -> Self::Future {
        self.inner.call(arg)
            .boxed()
    }

    fn poll_ready(&self) -> Async<()> {
        Async::Ready(())
    }
}

impl {{service.ident}}Service for {{service.ident}}Client {
    {{~#each service.methods as |method|}}
    {{> method method = method}} {
        use {{../namespace}}::{{../service.ident}}ServiceMethodArgs::*;
        use {{../namespace}}::{{../service.ident}}ServiceMethodReturn::*;
        let args = {{../service.ident}}{{method.ident}}Args {
            {{~#each args as |arg| }}
            {{arg.ident}}: {{arg.ident}},
            {{~/each}}
        };
        let ret = self.call(A{{method.ident}}(args)).map(|r| {
            if let R{{method.ident}}(ret) = r {
                ret
            } else {
                unreachable!("generated code error. map be a bug.");
            }
        });
        Box::new(ret)
    }
    {{~/each}}
}
