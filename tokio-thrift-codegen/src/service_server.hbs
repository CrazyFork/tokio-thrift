pub struct {{service.ident}}ServerCodec;

impl Codec for {{service.ident}}ServerCodec {
    type In = {{service.ident}}ServiceMethodArgs;
    type Out = {{service.ident}}ServiceMethodReturn;

    fn decode(&mut self, buf: &mut EasyBuf) -> Result<Option<Self::In>, io::Error> {
        let cur = io::Cursor::new(buf);
        let mut protocol = BinaryProtocol::from(cur);
        let ret = Self::In::deserialize(&mut protocol)?;
        let cur = protocol.into_inner();
        let size = cur.position();
        let buf = cur.into_inner();
        buf.drain_to(size as usize);
        Ok(Some(ret))
    }

    fn encode(&mut self, msg: Self::Out, buf: &mut Vec<u8>) -> io::Result<()> {
        let mut protocol = BinaryProtocol::from(buf);
        msg.serialize(&mut protocol).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))
    }
}


pub struct {{service.ident}}ServerProto;

impl<T: Io + 'static> ServerProto<T> for {{service.ident}}ServerProto {
    type Request = {{service.ident}}ServiceMethodArgs;
    type Response = {{service.ident}}ServiceMethodReturn;
    type Transport = Framed<T, {{service.ident}}ServerCodec>;
    type BindTransport = Result<Self::Transport, io::Error>;

    fn bind_transport(&self, io: T) -> Self::BindTransport {
        Ok(io.framed({{service.ident}}ServerCodec))
    }
}

#[derive(Clone)]
pub struct {{service.ident}}Server<T>
{
    inner: T,
}

impl <T: {{service.ident}}Service>{{service.ident}}Server<T>
{
    pub fn new(inner: T) -> Self
    {
        {{service.ident}}Server {
            inner: inner
        }
    }
}

impl <T>Service for {{service.ident}}Server<T>
    where T: {{service.ident}}Service
{
    type Request = {{service.ident}}ServiceMethodArgs;
    type Response = {{service.ident}}ServiceMethodReturn;
    type Error = io::Error;
    type Future = BoxFuture<{{service.ident}}ServiceMethodReturn, io::Error>;


    fn call(&self, req: Self::Request) -> Self::Future {
        use {{../namespace}}::{{service.ident}}ServiceMethodArgs::*;
        use {{../namespace}}::{{service.ident}}ServiceMethodReturn::*;
        match req {
            {{~#each service.methods as |method|}}
            A{{method.ident}}(_args)  => self.inner.{{method.ident}}(
                {{~#each method.args as |arg|}}
                _args.{{arg.ident}},
                {{~/each}}
            ).then(|r| finished(R{{method.ident}}(r))).boxed(),
            {{~/each}}
        }
    }
}
