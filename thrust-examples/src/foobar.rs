// autogenerated by thrust
#![allow(dead_code, unused_imports)]
use thrust::protocol::{Error, ThriftType};
use thrust::{ThrustResult, ThrustError};
use thrust::dispatcher::{self, Dispatcher, Incoming};
use thrust::reactor::Message;
use std::thread::JoinHandle;
use std::net::SocketAddr;
use std::sync::mpsc::{Sender, Receiver};
use tangle::{Future, Async};
use std::collections::{HashMap, HashSet};
use thrust::protocol::{ThriftDeserializer, ThriftSerializer};
use thrust::protocol::{Serializer, Deserializer};
use thrust::protocol::{Deserialize, Serialize, ThriftMessage, ThriftMessageType};
use thrust::binary_protocol::{BinarySerializer, BinaryDeserializer};
use thrust::Runner;


pub trait BlizzardService: Send {
    fn ack(&mut self, source_id: i64, tuple_id: i64) -> Future<String>;
}

pub struct BlizzardClient {
    dispatcher: Sender<dispatcher::Incoming>,
    pub handle: JoinHandle<ThrustResult<()>>,
}


impl BlizzardClient {
    pub fn new(addr: SocketAddr) -> BlizzardClient {
        let (handle, tx) = Dispatcher::spawn(dispatcher::Role::Client(addr)).unwrap();

        BlizzardClient {
            dispatcher: tx,
            handle: handle,
        }
    }
}

struct Blizzard_ack_Args {
    source_id: i64,
    tuple_id: i64,
}

impl Serialize for Blizzard_ack_Args {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
      where S: Serializer + ThriftSerializer
    {
        try!(s.write_struct_begin("Blizzard_ack_Args"));
        try!(s.write_field_begin("source_id", ThriftType::I64, 1));
        try!(self.source_id.serialize(s));
        try!(s.write_field_stop());
        try!(s.write_field_end());
        try!(s.write_field_begin("tuple_id", ThriftType::I64, 2));
        try!(self.tuple_id.serialize(s));
        try!(s.write_field_stop());
        try!(s.write_field_end());
        try!(s.write_struct_end());
        Ok(())
    }
}
impl Deserialize for Blizzard_ack_Args {
    fn deserialize<D>(de: &mut D) -> Result<Self, Error>
      where D: Deserializer + ThriftDeserializer
    {
        try!(de.read_struct_begin());
        let args = Blizzard_ack_Args {
            source_id: {
                match try!(de.read_field_begin()).ty {
                    ThriftType::Stop => { try!(de.read_field_begin()); },
                    _ => {}
                }
                let val = try!(de.deserialize_i64());
                try!(de.read_field_end());
                val
            },
            tuple_id: {
                match try!(de.read_field_begin()).ty {
                    ThriftType::Stop => { try!(de.read_field_begin()); },
                    _ => {}
                }
                let val = try!(de.deserialize_i64());
                try!(de.read_field_end());
                val
            },
        };
        try!(de.read_struct_end());
        Ok(args)
    }
}
impl BlizzardService for BlizzardClient {

    fn ack(&mut self, source_id: i64, tuple_id: i64) -> Future<String> {
        use std::io::Cursor;
        let (res, future) = Future::<(ThriftMessage, BinaryDeserializer<Cursor<Vec<u8>>>)>::channel();
        let mut buf = Vec::new();
        {
            let mut se = BinarySerializer::new(&mut buf);
            se.write_message_begin("ack", ThriftMessageType::Call);
            let args = Blizzard_ack_Args {
                source_id: source_id,
                tuple_id: tuple_id,
            };
            args.serialize(&mut se);
            se.write_message_end();
        }

        self.dispatcher.send(Incoming::Call("ack".to_string(), buf, Some(res))).unwrap();
        future.and_then(move |(msg, mut de)| {
            de.read_struct_begin();
            de.read_field_begin();
            let ret = de.deserialize_str().unwrap();
            de.read_field_end();
            de.read_struct_end();
            Async::Ok(ret)
        })
    }
}

// impl<S> Runner for BlizzardRunner<S>
//     where S: BlizzardService
// {
//     fn run<D>(&mut self, de: &mut D, msg: ThriftMessage) -> Result<Future<Vec<u8>>, Error>
//         where D: Deserializer + ThriftDeserializer,
//     {
//         match &*msg.name {
            // "ack" => {
            //     let args: Blizzard_ack_Args = try!(Deserialize::deserialize(de));
            //     let ret = self.service.ack(args.source_id, args.tuple_id).map(|val| {
            //         let mut buf = Vec::new();
            //         {
            //             let mut s = BinarySerializer::new(&mut buf);
            //             s.write_message_begin("ack", ThriftMessageType::Reply);
            //             s.write_struct_begin("ack_ret");
            //             s.write_field_begin("ret", ThriftType::String, 1);
            //             val.serialize(&mut s);
            //             s.write_field_stop();
            //             s.write_field_end();
            //             s.write_struct_end();
            //             s.write_message_end();
            //         }

            //         buf
            //     });
            //     Ok(ret)
            // },
            // _ => unimplemented!()
        // }
    // }
// }

// pub struct BlizzardRunner<S: BlizzardService> {
//     service: S
// }

// impl<S> BlizzardRunner<S> where S: BlizzardService {
//     pub fn new(service: S) -> BlizzardRunner<S> {
//         BlizzardRunner {
//             service: service
//         }
//     }
// }

// pub struct BlizzardServer {
//     dispatcher: Sender<dispatcher::Incoming>,
//     pub handle: JoinHandle<ThrustResult<()>>,
// }

// impl BlizzardServer {
//     /// ```notrust
//     /// BlizzardServer::new(Server, addr);
//     /// ```
//     pub fn new<S>(service: S, addr: SocketAddr) -> BlizzardServer
//         where S: 'static + BlizzardService
//     {
//         use std::thread;
//         use std::sync::mpsc::channel;
//         use std::io::Cursor;

//         let (sender, receiver) = channel();
//         let (handle, tx) = Dispatcher::spawn(dispatcher::Role::Server(addr, sender)).unwrap();

//         let send_tx = tx.clone();
//         thread::spawn(move || {
//             let mut runner = BlizzardRunner::new(service);
//             for (token, buf) in receiver.iter() {
//                 let mut de = BinaryDeserializer::new(Cursor::new(buf));
//                 match de.read_message_begin() {
//                     Ok(msg) => {
//                         match runner.run(&mut de, msg) {
//                             Ok(f) => {
//                                 let chan = send_tx.clone();
//                                 f.and_then(move |buf| {
//                                     chan.send(Incoming::Reply(token, buf));
//                                     Async::Ok(())
//                                 });
//                             },
//                             Err(err) => {}
//                         }
//                     },
//                     Err(err) => {
//                         println!("[server]: error parsing thrift message: {:?}", err);
//                     }
//                 }
//             }
//         });

//         BlizzardServer {
//             dispatcher: tx,
//             handle: handle,
//         }
//     }
// }
